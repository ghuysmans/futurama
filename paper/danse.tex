%FIXME mettre en évidence les définitions et propriétés ?
%FIXME pour les mathématiciens, donner de quoi le faire à la main : à partir de
%la séparation, montrer le paquet et donner le résumé qu'ils utiliseront

\title{Les tableaux}
\author{Guillaume \textsc{Huysmans}}%, Quentin \textsc{Carpentier}}
\date{23 janvier 2020}
\begin{document}
\maketitle

\begin{teacheronly}
\section*{Programme}
\subsection*{Compétences de 3TT en FWB}
\begin{tabular}{l|l}
10.1 & Analyser une situation-problème et
	modéliser la solution sous forme d'algorithme \\
10.5 & Traduire une opération, une fonction en langage de programmation \\
10.6 & Écrire un programme utilisant des séquences alternatives, répétitives \\
10.7 & Construire un programme modulaire \\
10.8 & Manipuler les tableaux
\end{tabular}
\subsection*{Prérequis}
J'ai déjà abordé la récursivité avec mes élèves lors d'une séance sur les tours
de Hanoï. Je les fais habituellement jongler entre deux notations : le
pseudo-code et le langage choisi en classe (ici, j'ai pris Python mais je ne
suis pas encore fixé).
Ils ont déjà utilisé des variables et des structures conditionnelles.
\end{teacheronly}

\section{Introduction}

\emph{Le problème décrit ici dérive d'Advent of Code
\footnote{\url{https://adventofcode.com/2017/day/16}},
le calendrier de l'Avent d'Eric Wastl.}

Une société de petits personnages adore la danse. Chaque année, pour Noël, ils
organisent une grande fête à laquelle leur Grande Reine Vénérée participe. Sa
Majesté n'autorise pas tout et n'importe quoi : \tbold{seules les danses qui La
font commencer et finir à la première place sont permises.}
Si elle finit à une autre place, le
chorégraphe est exécuté. C'est ce qui est arrivé au chorégraphe de la Cour
l'année passée : il faut dire qu'avec son grand âge, il n'avait déjà plus toute
sa tête. Cette année, c'est à son fils de prendre la relève : tous les autres
ont bien trop peur de mourir pour un pas de travers. Il doit faire quelque
chose de grandiose s'il veut faire oublier l'erreur de son père et profiter de
ses cadeaux sous le sapin.
Le problème, c'est qu'il a laissé tomber ses papiers quelques
jours avant Noël et qu'il avait oublié de les numéroter.
Il a presque réussi à les remettre dans l'ordre mais \tbold{il hésite entre
deux possibilités} et il n'a plus le temps de \tbold{les essayer}.

Représentés par des lettres majuscules ($A$ correspond à la reine...),
ils commencent dans l'ordre (${A\dots P}$) avant d'enchaîner une suite de pas
de deux types :
\begin{itemize}
\item \tbold{\texttt{spin}} $n$ ($\forall n \in \{1\dots15\}$) :
	%\marginpar{expliquer la notation : $\forall x \in E$...}
	les \tbold{$n$ derniers} viennent devant les premiers. \\
	Par exemple, \texttt{spin 3} sur \texttt{DACB} donne \texttt{ACBD}.
\item \tbold{\texttt{exchange}} $i$ $j$ ($\forall i,j \in \{0\dots15\}$) :
	ceux en $i$ et $j$ échangent leur place. \\
	Par exemple, \texttt{exchange 0 2} sur \texttt{CBDA} donne \texttt{DBCA}.
\end{itemize}

\begin{exo}
\emph{Surlignez} les mots importants de l'histoire ci-dessus.
\end{exo}

Le concept de variable abordé lors du cours précédent permet déjà de simuler
l'exécution d'une danse. Pour cela, stockons le nom des occupants de chaque
case dans des variables différentes : soient $v_0\in\{A\dots P\}$ le personnage
à la \emph{première} position, $v_1$ son voisin...
jusqu'à $v_{15}$, le dernier.

\begin{exo}
\emph{Complétez} l'algorithme correspondant à \texttt{exchange 0 1} :
\marginpar{couleurs}
\begin{enumerate}
\item \pbox{$t\phantom{_0}$} $\leftarrow$ \pbox{$v_0$}
\item \pbox{$v_0$} $\leftarrow$ \pbox{$v_1$}
\item \pbox{$v_1$} $\leftarrow$ \pbox{$t\phantom{_0}$}
\end{enumerate}
\end{exo}

Il semble difficile de généraliser ce petit algorithme à n'importe quels
$i,j \in \{0\dots15\}$ : en Python, le nom d'une variable est littéral, donc
en général
\texttt{vi} ne fait pas référence à $v_i$ avec $i\in\mathbb{N}$ mais à une
\emph{nouvelle variable} au nom trompeur.
%Nous ne verrons pas vu comment référencer une variable dont le nom dépend
%d'une autre variable, il est généralement possible 

\begin{exo}
\emph{Rappelez} les deux façons d'utiliser une variable \texttt{x} en Python :
\begin{itemize}
\item \tonly{\texttt{x}}
\item \tonly{\texttt{x = e} où \texttt{e} est une expression}
\end{itemize}
\end{exo}

Si nous tenons à utiliser des <<~variables numérotées~>>, nous allons devoir
les doter des deux opérations supportées par les variables habituelles.

\begin{exo}
\emph{Complétez} l'algorithme naïf \texttt{lire}$(i\in\{0\dots15\})$ :
\begin{enumerate}
\item si \pbox{$i=0$} alors retourner \pbox{$v_0$}
\item sinon, si \pbox{$i=1$} alors retourner \pbox{$v_1$}
\item sinon, si \pbox{$i=2$} alors retourner \pbox{$v_2$}
\item etc.
\end{enumerate}
\end{exo}

\begin{exo}
\emph{Complétez} l'algorithme naïf \texttt{écrire}$(i\in\{0\dots15\}, x)$ :
\begin{enumerate}
\item si \pbox{$i=0$} alors
	\pbox{$v_0$} $\leftarrow$ \pbox{$x\phantom{_0}$}
\item sinon, si \pbox{$i=1$} alors
	\pbox{$v_1$} $\leftarrow$ \pbox{$x\phantom{_0}$}
\item sinon, si \pbox{$i=2$} alors
	\pbox{$v_2$} $\leftarrow$ \pbox{$x\phantom{_0}$}
\item etc.
\end{enumerate}
\end{exo}

\begin{exo}
\emph{Déterminez} l'indice du dernier élément d'un tableau de
$n\in\mathbb{N}_0$ éléments.
\end{exo}

Tout cela devient vite pénible, et comme ce problème est récurrent, la plupart
des langages de programmation proposent une \emph{structure de données}
adaptée : le \emph{tableau}.
Un tableau de $n\in\mathbb{N}$ éléments de type $\alpha$ supporte deux
opérations élémentaires :
\begin{itemize}
\item \texttt{get}$(i\in\pbox{$\{0\dots n-1\}$}) : \alpha$ lit l'élément
	d'indice $i$ du tableau. \\
	En Python : \texttt{t[i]}
\item \texttt{set}$(i\in\pbox{$\{0\dots n-1\}$}, x\in\alpha)$ remplace
	l'élément d'indice $i$ par $x$. \\
	En Python : \texttt{t[i] = x}
\end{itemize}

Nous adopterons une notation graphique pour les représenter, même si \emph{un
programme ne verra pas directement où se trouve chacun de ses éléments},
contrairement à nous :
\marginpar{couleurs dans leur dos pour ne pas les voir direct'}
\newcommand{\boxes}[4]{
	$\begin{array}{|l|l|l|l|}\hline
	\ptonly{#1} & \ptonly{#2} & \ptonly{#3} & \ptonly{#4} \\ \hline
	\end{array}$
}
\newcommand{\emptyboxes}{
	\boxes{\phantom{a}}{\phantom{a}}{\phantom{a}}{\phantom{a}}
}
\begin{equation*}
	\texttt{['a', 'b', 'c', 'd']} \equiv
	\begin{array}{|l|l|l|l|}\hline
		a & b & c & d \\ \hline
	\end{array}
\end{equation*}

En Python\footnote{Ce n'est pas vrai dans tous les langages de programmation.},
un tableau peut changer de taille au cours de l'exécution du programme :
\begin{itemize}
\item \texttt{[]} est un \emph{nouveau} tableau vide.
	\marginpar{sinon plus possible d'utiliser \texttt{[]}
	après \texttt{[].append}}
\item \texttt{t.append(x)} ajoute un élément à la fin de \texttt{t}.
\item \texttt{len(t)} retourne la longueur de $t$.
\end{itemize}

Ces nouvelles fonctionnalités peuvent compliquer les raisonnements sur les
indices auxquels on accède : sortir d'un tableau n'est pas permis, et en
Python, cela ne se traduit pas toujours par le crash de notre programme !

\begin{exo}
\emph{Tapez} les instructions suivantes dans le
REPL\footnote{\emph{Read-Eval-Print Loop}} et
\emph{expliquez} chaque résultat :
\begin{enumerate}
	\item \texttt{t = []} \tonly{crée un tableau vide}
		\dotfill \boxes ////
	\item \texttt{print(t[0])} \tonly{lève une \texttt{IndexError}}
		\dotfill
	\item \texttt{t.append(2)}
		\dotfill \boxes 2///
	\item \texttt{print(t[0])} \tonly{affiche 2, le premier élément}
		\dotfill
	\item \texttt{print(t[-1])} \tonly{devrait les surprendre}
		\dotfill
	\item \texttt{t.append(4)}
		\dotfill \boxes 24//
	\item \texttt{print(t[-1])} \tonly{affiche 4, le dernier élément}
		\dotfill
	\item \texttt{t.append(6)}
		\dotfill \boxes 246/
	\item \texttt{t.append(8)}
		\dotfill \boxes 2468
	\item \texttt{print(t[-2])} \tonly{affiche 6, l'avant-dernier élément}
		\dotfill
	\item \texttt{print(t[1.5])} \tonly{lève une \texttt{TypeError}}
		\dotfill
\end{enumerate}
\end{exo}

\section{Simulation}
Pour simplifier, limitons-nous à 4 personnages
représentés par quatre lettres.

\begin{exo}\label{ex:sim}
Sur papier, \emph{simulez} les étapes successives de cette danse :
	\begin{enumerate}%[label=\alph*.]
	\item (positions initiales) \hfill \boxes abcd
	\item \texttt{spin 3} \hfill \boxes bcda
	\item \texttt{exchange 0 1} \hfill \boxes cbda
	\item \texttt{spin 1} \hfill \boxes acbd
	\item \texttt{exchange 2 3} \hfill \boxes acdb
	\end{enumerate}
\end{exo}

%\begin{minipage}{\textwidth}
\begin{exo}
\emph{Complétez} ces schémas puis \emph{implémentez} \texttt{exchange} :
	\marginpar{cases vides !!}
\begin{multicols}{2}
	\begin{enumerate}[label=]
	\item \emptyboxes \texttt{spin$(n\in\{1\dots4\})$}
	\item \emptyboxes \texttt{exchange$(i, j\in\{0\dots3\})$}
	\end{enumerate}
\end{multicols}
\end{exo}
%\end{minipage}

\begin{exo}
En permutant deux pas, le résultat change...
(n'oubliez pas de \emph{justifier} !) :
	\begin{enumerate}
		\item toujours ?
			\tonly{$x_{01}\circ x_{23}=x_{23}\circ x_{01}\equiv$\boxes badc}
			\marginpar{détailler une fois au tableau}
			\dotfill
		\item jamais ?
			\tonly{$x_{01}\circ x_{12}\equiv$\boxes cabd$\ne$
			\boxes bcad$\equiv x_{12}\circ x_{01}$}
			\dotfill
		\item parfois ? \tonly{parce qu'on a contredit les deux précédentes !}
			\dotfill
	\end{enumerate}
\end{exo}

\begin{exo}
Schématisez une manière d'aider notre chorégraphe favori.
\begin{enumerate}
\item \tonly{Exécuter la première possibilité.}
\item \tonly{Tester \texttt{t[-1] == 'a'}.}
\item \tonly{Si c'est vrai, c'est la bonne, sinon, c'est l'autre.}
\end{enumerate}
\end{exo}

Remarquez qu'aucun personnage ne peut disparaître du tableau.
\begin{exo}
\emph{Écrivez} l'algorithme
\texttt{trouve}$(i\in\{0\dots15\}, x\in\{A\dots P\})$ qui retrouve la position
d'un personnage dans notre simulation en commençant par la $i$ème case.
\begin{enumerate}
\item \tonly{Si \texttt{t[i] == x}, retourner $i$.}
	\dotfill
\item \tonly{Sinon, poursuivre la recherche à partir de l'indice $i+1$.}
	\dotfill
\end{enumerate}
\end{exo}
\begin{exo}[Préparation]
	\emph{Expliquez} comment corriger une danse. \marginpar{\texttt{exchange}}
\end{exo}

\section{Optimisations}
\begin{comment}
Grâce à vous, Noël se passera bien pour notre ami.
Il nous doit une \emph{reconnaissance éternelle}
mais il a encore un <<~petit quelque chose~>> à nous demander.

Il a entendu dire que
Sa~Majesté se lassait de tout ça et qu'elle avait décidé de changer les règles :
pendant le prochain milliard d'années (ils vivent tous très longtemps mais la
principale cause de mortalité est la décapitation), l'Élu
(qu'Elle essaiera de ne pas exécuter entre-temps, Elle fera un effort)
participera à sa place et ils reprendront du même endroit l'année suivante.
%Grâce à ses talents de négociateur, il a pu obtenir de Sa~Majesté qu'elle
%accepte plus de danses originales (Elle n'est plus toujours première à la fin)
%à condition qu'après un milliard d'années, Elle finisse à nouveau la première.
La danse ne changera pas (quel intérêt si Elle ne regarde pas ?).
Le chorégraphe doit maintenant prédire la position exacte des danseurs après
tout ce temps. S'il se trompe, il sera exécuté, lui et toute sa famille.
%Son règne n'est pas près de s'arrêter : Sa~Majesté est immortelle.
\end{comment}

\subsection{Ça tourne...}

\begin{exo}
\emph{Représentez} les personnages sur un cercle et
\emph{répondez} aux questions suivantes :
\begin{enumerate}
\item Où se trouve le premier danseur ?
	\marginpar{flèche}
\item Y a-t-il plusieurs façons de lire un tel schéma ?
	\marginpar{sens de rotation}
\item Que fait \texttt{spin 2} ? Est-ce que ça va plus vite ?
	\marginpar{compter à partir de la flèche}
\item Que fait \texttt{exchange 0 3} après \texttt{spin 2} ?
\item Un tableau est-il encore adapté ?
	\marginpar{plier, montre.}
	\begin{itemize}
	\item Si c'est le cas, \emph{représentez}-le à plat.
	\item Sinon, \emph{expliquez} pourquoi c'est impossible.
	\end{itemize}
\end{enumerate}
\end{exo}

\subsection{Périodicité}
En écrivant $d(x)$ le résultat de la danse $d$ sur les positions des danseurs
$x$, les positions à la fin de chaque danse peuvent être modélisées à l'aide
d'une suite :\[
	\forall n \in \mathbb{N} \quad u_n =
	\left\{\begin{array}{ll}
		\texttt{ABCDEFGHIJKLMNOP} & \text{si $n=0$} \\
		d\left(u_{n-1}\right) & \text{sinon}
	\end{array}\right.
\]

\emph{Il se peut} qu'il ne soit pas nécessaire de calculer $u_{1000000000}$ :
\begin{center}
	\begin{tikzpicture}[node distance=1.5cm]
		\node (0) {$u_0$};
		\node (1) [right of=0] {$u_1$};
		\node (2) [right of=1] {$u_2$};
		\node (i) [right of=2] {$u_i$};
		\node (i+1) [right of=i] {$u_{i+1}$};
		\node (i+2) [right of=i+1] {$u_{i+2}$};
		\node (j) [above of=i,node distance=1cm] {$u_j$};
		\node (j+1) [above of=i+1,node distance=1cm] {$u_{j+1}$};
		\node (j+2) [above of=i+2,node distance=1cm] {$u_{j+2}$};
		\draw (0) edge[->] node [above,midway] {$d$} (1);
		\draw (1) edge[->] node [above,midway] {$d$} (2);
		\draw (2) edge[->] node [above,midway] {$\dots$} (i);
		\draw (i) edge[->] node [above,midway] {$d$} (i+1);
		\draw (i+1) edge[->] node [above,midway] {$d$} (i+2);
		\draw (i+2) edge[->,bend left] node [below,midway] {} (i);
		%\draw (j) edge[->] node [above,midway] {$d$} (j+1);
		%\draw (j+1) edge[->] node [above,midway] {$d$} (j+2);
		%\draw (j+2) edge[->,bend right] node [above,midway] {$\dots$} (j);
		\draw (i) edge[double equal sign distance] (j);
		\draw (i+1) edge[double equal sign distance] (j+1);
		\draw (i+2) edge[double equal sign distance] (j+2);
	\end{tikzpicture}
\end{center}

\begin{exo}
À partir du dessin, \emph{déduisez} $k$, la période de la danse.
\begin{equation*}
k=\pbox{2+1=3}
\end{equation*}
\end{exo}

En pratique, la période pourrait être assez longue, c'est pourquoi \emph{on ne
stockera pas toutes les valeurs en mémoire}.
Ce problème a déjà été étudié %en théorie des graphes (un graphe est un ensemble
%de \emph{points} ou \emph{noeuds} reliés par \emph{arêtes})
par des mathématiciens
et nous allons redécouvrir l'\emph{algorithme du lièvre et de la tortue}.

Imaginons une course entre un lièvre et une tortue sur le parcours formé par
$u_n$. Évidemment, le lièvre court plus vite que la tortue (disons deux fois
plus vite). Dans cette course, avancer correspond à effectuer toute une danse
(de notre problème initial).

\begin{exo}
Avec votre voisin, faites la course sur le dessin (pour l'exemple, disons que
$i=3$) et \emph{retrouvez} la période $k$ à partir de vos positions respectives.
\end{exo}

\begin{exo}[Préparation]
\emph{Essayez} d'implémenter la simulation de cette course.
\end{exo}

\begin{teacheronly}
\section*{La suite}
La véritable préparation notée au journal de classe dépendra de l'avancement de
la classe.

Pour réellement implémenter la simulation, plusieurs approches sont
envisageables :
\begin{itemize}
\item \emph{parser} les pas stockés dans un fichier texte semblable à ce qui
	est produit par le générateur original : le code n'est pas particulièrement
	compliqué mais autant évaluer une chose à la fois. Même en BAB1, c'est non
	trivial (cf. séance CPUMONS).
\item générer une longue fonction qui effectue une danse : ce n'est pas d'une
	grande élégance mais ça a le mérite d'être transparent et plus facile à
	déboguer. Un autre avantage de cette approche est qu'elle leur montre
	qu'une optimisation peut être non triviale.
\end{itemize}

La notion de \emph{type somme}
\footnote{En OCaml, \texttt{type t = Spin of int | Exchange of int * int}}
(avec le \emph{pattern matching}
\footnote{\texttt{match s with Spin n -> ... | Exchange (i, j) -> ...}}) peut
aider à mieux structurer le programme et montre une alternative à la POO au
moins aussi élégante.

Pour faire du dépassement, j'ai le choix entre différents parcours :
\begin{itemize}
\item un peu de programmation fonctionnelle pour exhiber
	la composition de fonctions
\item seconde partie avec une nouvelle opération
	\texttt{partner}$(x, y\in\{A\dots P\})$
\end{itemize}
\end{teacheronly}

\end{document}
